## 034. 找出有序数组中target第一次出现和第二次出现的位置

**题意**

给一个整数、升序排列的数组`nums`，找出`target`出现的第一个位置和最后一个位置。

要求算法时间复杂度为$O(log N)$。如果没找到，则返回[-1, -1].

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```

**解法**

- 思路一

看到时间复杂度，就应该往二分法这个方向去思考。

自己思考的方法如下：

全程需要维护一个数组res，该数组中有两个值，res[0]是当前可以求得的target的最小的坐标，res[1]是当前可以求得的target的最大的坐标。首先对于原来的数组，用二分法去找target。如果没有找到，那么直接返回[-1, -1]就可以了。如果找到了target的位置，那么此时可以用该位置下标来更新res的值。接下来，在该位置的左半部分和右半部分递归搜索，每次找到了target都要来更新数组res。

* 思路二

c++库函数：

`equal_range()`是STL中的一种二分查找的算法，试图在已经排序的[first, last)中寻找一个value可以插入的位置，返回的是一对迭代器i和j，
i是在不破坏次序的前题下，value可以插入的第一个位置(也就是lower_bound)，
j则是在不破坏次序的前题下，value可以插入的最后一个位置（也就是upper_bound）
也就是，[i, j)内的每一个元素都等于value，而[i, j)是符合这一性质的最大子区间。

当[first, last)并未含有与value相等的元素，“与value相等”的所有元素形成的区间应该是一个空区间，在不破坏次序的情况下，只有一个位置可以插入value。也就是说此时返回的i和j应该是指向同一个位置。

* 思路三

使用库函数：`lower_bound`和`upper_bound`

* 思路四

分治法。

因为数组是有序的，首先判断target是否在该数组区间中（大于等于最左边数，小于等于最右边数）。然后找到该区间的中间位置m，如果刚好和target相等，那么，取左(右)边的子区间重复上面过程，找到子区间内target的最左(右)端(如果不存在，那么最后返回的数组的最左(右)端还是位置m。如果m位置的值和target不相等，那么缩小区间继续二分来完成上面过程。