## 034. 找出有序数组中target第一次出现和第二次出现的位置

**题意**

给一个整数、升序排列的数组`nums`，找出`target`出现的第一个位置和最后一个位置。

要求算法时间复杂度为$O(log N)$。如果没找到，则返回[-1, -1].

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```

**解法**

- 思路一

看到时间复杂度，就应该往二分法这个方向去思考。

自己思考的方法如下：

全程需要维护一个数组res，该数组中有两个值，res[0]是当前可以求得的target的最小的坐标，res[1]是当前可以求得的target的最大的坐标。首先对于原来的数组，用二分法去找target。如果没有找到，那么直接返回[-1, -1]就可以了。如果找到了target的位置，那么此时可以用该位置下标来更新res的值。接下来，在该位置的左半部分和右半部分递归搜索，每次找到了target都要来更新数组res。

* 思路二

c++库函数：

`equal_range()`是STL中的一种二分查找的算法，试图在已经排序的[first, last)中寻找一个value可以插入的位置，返回的是一对迭代器i和j，
i是在不破坏次序的前题下，value可以插入的第一个位置(也就是lower_bound)，
j则是在不破坏次序的前题下，value可以插入的最后一个位置（也就是upper_bound）
也就是，[i, j)内的每一个元素都等于value，而[i, j)是符合这一性质的最大子区间。

当[first, last)并未含有与value相等的元素，“与value相等”的所有元素形成的区间应该是一个空区间，在不破坏次序的情况下，只有一个位置可以插入value。也就是说此时返回的i和j应该是指向同一个位置。

* 思路三

使用库函数：`lower_bound`和`upper_bound`

* 思路四

分治法。

因为数组是有序的，首先判断target是否在该数组区间中（大于等于最左边数，小于等于最右边数）。然后找到该区间的中间位置m，如果刚好和target相等，那么，取左(右)边的子区间重复上面过程，找到子区间内target的最左(右)端(如果不存在，那么最后返回的数组的最左(右)端还是位置m。如果m位置的值和target不相等，那么缩小区间继续二分来完成上面过程。

## 039. 组合数之和

**题意**

给你一个候选numbers的集合set(没有重复数)和一个target，找出所有的组合方法，组合内所有数来自set并且和等于target。

所有的number和target都是正整数。

```
Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```
## 083. 移除有序链表中的重复元素【注意，递归方法总是写错】

**题意**

删除一个有序链表中的重复元素，使得每个元素最多出现一次。

```
Input: 1->1->2->3->3
Output: 1->2->3
```

**解法**

* 思路一

递归。这道题其实很简单，一开始我就想的是用递归来写，但是代码一直有bug。主要还是递归的思路不够清晰。应该是先考虑相邻的两个的两个元素，如果这两个元素是不相同的，那么直接以第二个元素为头节点进行递归。如果这两个元素是一样的，那么就移动第二个指针，直到两个指针所指元素相同或者第二个指针指向nullptr的时候，以第二个指针为头节点进行递归。

* 思路二

非递归的方法。每次找到和当前元素不相同的元素，再进行指针的调整。

* 思路三

非递归的方法。每次找到一个和当前元素相同的元素，则将这个新找到的元素删除。

